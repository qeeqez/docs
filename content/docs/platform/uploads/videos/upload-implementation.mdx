---
title: Upload Implementation
description: Code examples and best practices for implementing video uploads
---

import {  InfoCard } from '@/components';
import { Tabs, Tab} from 'fumadocs-ui/components/tabs';

Implement video uploads with comprehensive code examples and best practices for reliable, efficient video processing.

## Upload Implementation

### Implementation Overview

**Three-step upload process**:
1. **Initialize upload**: Get presigned URLs and upload configuration
2. **Upload video file**: Direct upload to secure cloud storage
3. **Complete upload**: Trigger processing pipeline

### Upload Optimization Guidelines

<div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
    <InfoCard
        title="Format: MP4 + H.264"
        description="Fastest processing with universal compatibility"
    />
    <InfoCard
        title="Resolution: Upload Highest Available"
        description="Up to 4K for Pro tier, system scales down appropriately"
    />
    <InfoCard
        title="Frame Rate: 30fps or 60fps"
        description="Standard rates for optimal processing and compatibility"
    />
    <InfoCard
        title="Audio: AAC Codec"
        description="Best compatibility and quality for source material"
    />
</div>

## Code Examples

<Tabs items={['JavaScript', 'Python', 'cURL']}>
<Tab value="JavaScript">
```javascript
// Initialize video upload
const initResponse = await fetch('https://api.rixl.com/v1/videos/upload/init', {
  method: 'POST',
  headers: {
    'X-API-Key': 'YOUR_PROJECT_API_KEY',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    file_name: 'my-video.mp4',
    video_quality: 'pro',
    image_format: 'jpg'
  })
});

if (!initResponse.ok) {
  throw new Error('Upload initialization failed');
}

const uploadData = await initResponse.json();

// Upload video file
const videoUpload = await fetch(uploadData.video_presigned_url, {
  method: 'PUT',
  body: videoFile,
  headers: {
    'Content-Type': 'video/mp4'
  }
});

if (!videoUpload.ok) {
  throw new Error('Video upload failed');
}

// Complete upload and start processing
const completeResponse = await fetch(`https://api.rixl.com/v1/videos/${uploadData.video_id}/upload/complete/`, {
  method: 'POST',
  headers: {
    'X-API-Key': 'YOUR_PROJECT_API_KEY'
  }
});

if (!completeResponse.ok) {
  throw new Error('Upload completion failed');
}

console.log('Video processing started!');
console.log('Video ID:', uploadData.video_id);
```
</Tab>

<Tab value="Python">
```python
import requests

# Initialize video upload
response = requests.post(
    'https://api.rixl.com/v1/videos/upload/init',
    headers={
        'X-API-Key': 'YOUR_PROJECT_API_KEY',
        'Content-Type': 'application/json'
    },
    json={
        'file_name': 'my-video.mp4',
        'video_quality': 'pro',
        'image_format': 'jpg'
    }
)

if response.status_code != 200:
    raise Exception('Upload initialization failed')

upload_data = response.json()

# Upload video file
with open('my-video.mp4', 'rb') as video_file:
    upload_response = requests.put(
        upload_data['video_presigned_url'],
        data=video_file,
        headers={'Content-Type': 'video/mp4'}
    )

if upload_response.status_code != 200:
    raise Exception('Video upload failed')

# Complete upload
complete_response = requests.post(
    f"https://api.rixl.com/v1/videos/{upload_data['video_id']}/upload/complete/",
    headers={'X-API-Key': 'YOUR_PROJECT_API_KEY'}
)

if complete_response.status_code != 200:
    raise Exception('Upload completion failed')

print('Video processing started!')
print(f"Video ID: {upload_data['video_id']}")
```
</Tab>

<Tab value="cURL">
```bash
# 1. Initialize upload
INIT_RESPONSE=$(curl -X POST https://api.rixl.com/v1/videos/upload/init \
  -H "X-API-Key: YOUR_PROJECT_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "file_name": "my-video.mp4",
    "video_quality": "pro",
    "image_format": "jpg"
  }')

# Extract values from response (requires jq)
VIDEO_ID=$(echo $INIT_RESPONSE | jq -r '.video_id')
PRESIGNED_URL=$(echo $INIT_RESPONSE | jq -r '.video_presigned_url')

# 2. Upload video (using presigned URL from response)
curl -X PUT "$PRESIGNED_URL" \
  --upload-file my-video.mp4 \
  -H "Content-Type: video/mp4"

# 3. Complete upload
curl -X POST https://api.rixl.com/v1/videos/$VIDEO_ID/upload/complete/ \
  -H "X-API-Key: YOUR_PROJECT_API_KEY"

echo "Video processing started! Video ID: $VIDEO_ID"
```
</Tab>
</Tabs>

## Advanced Implementation

### Error Handling and Retry Logic

**Robust upload implementation**:

```javascript
async function uploadVideoWithRetry(file, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Initialize upload
      const initResponse = await fetch('https://api.rixl.com/v1/videos/upload/init', {
        method: 'POST',
        headers: {
          'X-API-Key': 'YOUR_PROJECT_API_KEY',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          file_name: file.name,
          video_quality: 'basic',
          image_format: 'jpg'
        })
      });

      if (!initResponse.ok) {
        throw new Error(`Initialization failed: ${initResponse.status}`);
      }

      const uploadData = await initResponse.json();

      // Upload with progress tracking
      const uploadResponse = await uploadWithProgress(
        uploadData.video_presigned_url, 
        file,
        (progress) => console.log(`Upload progress: ${progress}%`)
      );

      // Complete upload
      const completeResponse = await fetch(
        `https://api.rixl.com/v1/videos/${uploadData.video_id}/upload/complete/`,
        {
          method: 'POST',
          headers: { 'X-API-Key': 'YOUR_PROJECT_API_KEY' }
        }
      );

      if (!completeResponse.ok) {
        throw new Error(`Completion failed: ${completeResponse.status}`);
      }

      return uploadData.video_id;

    } catch (error) {
      console.log(`Attempt ${attempt} failed:`, error.message);
      
      if (attempt === maxRetries) {
        throw new Error(`Upload failed after ${maxRetries} attempts: ${error.message}`);
      }
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

async function uploadWithProgress(url, file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable) {
        const progress = Math.round((event.loaded / event.total) * 100);
        onProgress(progress);
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        resolve(xhr.response);
      } else {
        reject(new Error(`Upload failed with status: ${xhr.status}`));
      }
    });
    
    xhr.addEventListener('error', () => {
      reject(new Error('Upload failed due to network error'));
    });
    
    xhr.open('PUT', url);
    xhr.setRequestHeader('Content-Type', file.type);
    xhr.send(file);
  });
}
```

### Large File Handling

**Multipart upload for files >100MB**:

```python
import requests
from requests_toolbelt.multipart.encoder import MultipartEncoder, MultipartEncoderMonitor

def upload_large_video(file_path, progress_callback=None):
    """Upload large video files with progress tracking and resume capability."""
    
    # Initialize upload
    init_response = requests.post(
        'https://api.rixl.com/v1/videos/upload/init',
        headers={
            'X-API-Key': 'YOUR_PROJECT_API_KEY',
            'Content-Type': 'application/json'
        },
        json={
            'file_name': os.path.basename(file_path),
            'video_quality': 'pro',
            'image_format': 'jpg',
            'multipart': True  # Enable multipart upload
        }
    )
    
    if init_response.status_code != 200:
        raise Exception('Upload initialization failed')
    
    upload_data = init_response.json()
    
    # Upload with progress monitoring
    def progress_monitor(monitor):
        if progress_callback:
            progress = int((monitor.bytes_read / monitor.len) * 100)
            progress_callback(progress)
    
    with open(file_path, 'rb') as f:
        encoder = MultipartEncoder(
            fields={'file': (os.path.basename(file_path), f, 'video/mp4')}
        )
        monitor = MultipartEncoderMonitor(encoder, progress_monitor)
        
        upload_response = requests.put(
            upload_data['video_presigned_url'],
            data=monitor,
            headers={'Content-Type': monitor.content_type}
        )
    
    if upload_response.status_code != 200:
        raise Exception('Video upload failed')
    
    # Complete upload
    complete_response = requests.post(
        f"https://api.rixl.com/v1/videos/{upload_data['video_id']}/upload/complete/",
        headers={'X-API-Key': 'YOUR_PROJECT_API_KEY'}
    )
    
    if complete_response.status_code != 200:
        raise Exception('Upload completion failed')
    
    return upload_data['video_id']

# Usage with progress tracking
def print_progress(percentage):
    print(f"Upload progress: {percentage}%")

video_id = upload_large_video('large-video.mp4', print_progress)
print(f"Upload complete! Video ID: {video_id}")
```

## Implementation Best Practices

### Quality Tier Selection

**Programmatic tier selection**:

```javascript
function selectOptimalTier(videoMetadata) {
  const { width, height, duration, fileSize } = videoMetadata;
  const resolution = width * height;
  const isVertical = height > width;
  
  // 4K or higher resolution
  if (resolution >= 3840 * 2160) {
    return 'pro';
  }
  
  // Vertical content or high frame rate
  if (isVertical || videoMetadata.frameRate >= 50) {
    return 'shorts';
  }
  
  // Large files likely high quality
  if (fileSize > 500 * 1024 * 1024) { // 500MB
    return 'pro';
  }
  
  // Default to basic for standard content
  return 'basic';
}

// Usage
const optimalTier = selectOptimalTier({
  width: 1920,
  height: 1080,
  duration: 300, // 5 minutes
  fileSize: 200 * 1024 * 1024, // 200MB
  frameRate: 30
});
```

### Processing Optimization

**Upload timing optimization**:

```python
from datetime import datetime, timezone
import pytz

def get_optimal_upload_time():
    """Determine optimal upload time based on timezone and server load."""
    
    # Convert to UTC for server processing
    utc_now = datetime.now(timezone.utc)
    hour_utc = utc_now.hour
    
    # Off-peak hours (UTC): 2 AM - 8 AM
    if 2 <= hour_utc <= 8:
        return True, "Optimal time - off-peak hours"
    
    # Peak hours (UTC): 12 PM - 6 PM  
    elif 12 <= hour_utc <= 18:
        return False, "Peak hours - consider uploading later"
    
    # Moderate load
    else:
        return True, "Moderate load - acceptable upload time"

# Usage
is_optimal, message = get_optimal_upload_time()
if is_optimal:
    print(f"Good time to upload: {message}")
else:
    print(f"Consider waiting: {message}")
```

### Security and Access Control

**Secure upload implementation**:

```javascript
class SecureVideoUploader {
  constructor(apiKey, projectId) {
    this.apiKey = apiKey;
    this.projectId = projectId;
    this.baseUrl = 'https://api.rixl.com/v1';
  }
  
  async validateFile(file) {
    // File size validation (2GB limit)
    if (file.size > 2 * 1024 * 1024 * 1024) {
      throw new Error('File size exceeds 2GB limit');
    }
    
    // MIME type validation
    const allowedTypes = ['video/mp4', 'video/quicktime', 'video/webm'];
    if (!allowedTypes.includes(file.type)) {
      throw new Error('Unsupported file type');
    }
    
    return true;
  }
  
  async uploadVideo(file, options = {}) {
    // Validate file before upload
    await this.validateFile(file);
    
    const requestBody = {
      file_name: file.name,
      video_quality: options.quality || 'basic',
      image_format: options.imageFormat || 'jpg',
      project_id: this.projectId
    };
    
    // Initialize with authentication
    const initResponse = await fetch(`${this.baseUrl}/videos/upload/init`, {
      method: 'POST',
      headers: {
        'X-API-Key': this.apiKey,
        'Content-Type': 'application/json',
        'User-Agent': 'RIXL-SDK/1.0'
      },
      body: JSON.stringify(requestBody)
    });
    
    if (!initResponse.ok) {
      const error = await initResponse.json();
      throw new Error(`Upload initialization failed: ${error.message}`);
    }
    
    const uploadData = await initResponse.json();
    
    // Verify presigned URL is secure (HTTPS)
    if (!uploadData.video_presigned_url.startsWith('https://')) {
      throw new Error('Insecure upload URL provided');
    }
    
    // Upload with timeout
    const uploadResponse = await Promise.race([
      fetch(uploadData.video_presigned_url, {
        method: 'PUT',
        body: file,
        headers: { 'Content-Type': file.type }
      }),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Upload timeout')), 300000) // 5 minutes
      )
    ]);
    
    if (!uploadResponse.ok) {
      throw new Error(`Upload failed: ${uploadResponse.status}`);
    }
    
    // Complete upload
    const completeResponse = await fetch(
      `${this.baseUrl}/videos/${uploadData.video_id}/upload/complete/`,
      {
        method: 'POST',
        headers: { 'X-API-Key': this.apiKey }
      }
    );
    
    if (!completeResponse.ok) {
      throw new Error('Upload completion failed');
    }
    
    return uploadData.video_id;
  }
}

// Usage
const uploader = new SecureVideoUploader('YOUR_API_KEY', 'YOUR_PROJECT_ID');

try {
  const videoId = await uploader.uploadVideo(videoFile, {
    quality: 'pro',
    imageFormat: 'jpg'
  });
  console.log('Upload successful:', videoId);
} catch (error) {
  console.error('Upload failed:', error.message);
}
```

## Performance Optimization

### Batch Upload Implementation

**Efficient multiple file uploads**:

```javascript
async function batchUploadVideos(files, options = {}) {
  const { concurrency = 3, quality = 'basic' } = options;
  const results = [];
  
  // Process files in batches to avoid overwhelming the server
  for (let i = 0; i < files.length; i += concurrency) {
    const batch = files.slice(i, i + concurrency);
    
    const batchPromises = batch.map(async (file, index) => {
      try {
        console.log(`Starting upload ${i + index + 1}/${files.length}: ${file.name}`);
        
        const videoId = await uploadVideoWithRetry(file);
        
        return {
          success: true,
          fileName: file.name,
          videoId: videoId
        };
      } catch (error) {
        return {
          success: false,
          fileName: file.name,
          error: error.message
        };
      }
    });
    
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
    
    // Brief pause between batches
    if (i + concurrency < files.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return results;
}

// Usage
const files = [video1, video2, video3, video4];
const results = await batchUploadVideos(files, { 
  concurrency: 2, 
  quality: 'pro' 
});

results.forEach(result => {
  if (result.success) {
    console.log(`✓ ${result.fileName} → ${result.videoId}`);
  } else {
    console.log(`✗ ${result.fileName} → ${result.error}`);
  }
});
```

## Troubleshooting

### Common Implementation Issues

**Upload failures and solutions**:

```javascript
class UploadTroubleshooter {
  static diagnoseError(error, context) {
    const { statusCode, message, file } = context;
    
    // File size issues
    if (file?.size > 2 * 1024 * 1024 * 1024) {
      return {
        issue: 'File size limit exceeded',
        solution: 'Compress video or split into smaller segments',
        code: 'FILE_TOO_LARGE'
      };
    }
    
    // Network issues
    if (statusCode >= 500 || message.includes('network')) {
      return {
        issue: 'Server or network error',
        solution: 'Retry upload with exponential backoff',
        code: 'NETWORK_ERROR'
      };
    }
    
    // Authentication issues
    if (statusCode === 401 || statusCode === 403) {
      return {
        issue: 'Authentication failed',
        solution: 'Verify API key and project permissions',
        code: 'AUTH_ERROR'
      };
    }
    
    // Presigned URL expiration
    if (statusCode === 403 && message.includes('expired')) {
      return {
        issue: 'Upload URL expired',
        solution: 'Reinitialize upload to get new presigned URL',
        code: 'URL_EXPIRED'
      };
    }
    
    return {
      issue: 'Unknown error',
      solution: 'Check error logs and contact support if persistent',
      code: 'UNKNOWN_ERROR'
    };
  }
}

// Usage in error handling
try {
  await uploadVideo(file);
} catch (error) {
  const diagnosis = UploadTroubleshooter.diagnoseError(error, {
    statusCode: error.status,
    message: error.message,
    file: file
  });
  
  console.log(`Issue: ${diagnosis.issue}`);
  console.log(`Solution: ${diagnosis.solution}`);
  console.log(`Code: ${diagnosis.code}`);
}
```

## Next Steps

- Set up [processing status monitoring](/docs/platform/uploads/videos/monitoring-status) to track upload progress
- Learn about [quality tiers](/docs/platform/uploads/videos/quality-tiers) to optimize processing choices
- Review [supported formats](/docs/platform/uploads/videos/supported-formats) for optimal compatibility

import type {Plugin} from "vite";
import {readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync} from "node:fs";
import {join, dirname, relative} from "node:path";
import * as lucideIcons from "lucide-react";

const CONTENT_DIR = "content";
const OUTPUT_FILE = "src/generated/icons.ts";

// Get valid icon names from lucide-react (filter out non-icon exports)
const validLucideIcons = new Set(
  Object.keys(lucideIcons)
    .filter((key) => /^[A-Z]/.test(key) && key !== "Icon" && key !== "createLucideIcon")
    .map((key) => toKebabCase(key))
);

// Converts PascalCase to kebab-case
function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])(\d)/gi, "$1-$2")
    .replace(/([A-Z])/g, "-$1")
    .toLowerCase()
    .replace(/^-/, "");
}

// Converts kebab-case to PascalCase for lucide-react imports
function toPascalCase(str: string): string {
  return str
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

// Recursively find all MDX files
function findMdxFiles(dir: string): string[] {
  const files: string[] = [];

  if (!existsSync(dir)) return files;

  const entries = readdirSync(dir, {withFileTypes: true});
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...findMdxFiles(fullPath));
    } else if (entry.name.endsWith(".mdx")) {
      files.push(fullPath);
    }
  }

  return files;
}

interface IconUsage {
  icon: string;
  file: string;
  line: number;
}

function extractIconsFromMdx(rootDir: string): {icons: Set<string>; usages: IconUsage[]} {
  const icons = new Set<string>();
  const usages: IconUsage[] = [];
  const contentDir = join(rootDir, CONTENT_DIR);

  // Pattern to match icon="icon-name" or icon='icon-name'
  const iconPattern = /icon=["']([a-z0-9-]+)["']/gi;

  const mdxFiles = findMdxFiles(contentDir);
  for (const file of mdxFiles) {
    const content = readFileSync(file, "utf-8");
    const lines = content.split("\n");

    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      let match;
      while ((match = iconPattern.exec(line)) !== null) {
        const iconName = match[1].toLowerCase();
        icons.add(iconName);
        usages.push({icon: iconName, file, line: lineNum + 1});
      }
    }
  }

  return {icons, usages};
}

function validateIcons(usages: IconUsage[], rootDir: string): string[] {
  const warnings: string[] = [];

  for (const usage of usages) {
    if (!validLucideIcons.has(usage.icon)) {
      const relPath = relative(rootDir, usage.file);
      warnings.push(`  âš ï¸  Unknown icon "${usage.icon}" in ${relPath}:${usage.line}`);
    }
  }

  return [...new Set(warnings)]; // Dedupe
}

function generateIconsFile(icons: Set<string>): string {
  // Filter to only valid icons
  const validIcons = Array.from(icons)
    .filter((icon) => validLucideIcons.has(icon))
    .sort();

  if (validIcons.length === 0) {
    return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by vite-plugin-extract-icons
// No icons found in MDX files

import type {LucideIcon} from "lucide-react";

export const iconMap: Record<string, LucideIcon> = {};

export type IconName = string;
`;
  }

  const imports = validIcons.map((icon) => toPascalCase(icon)).join(", ");
  const mapEntries = validIcons.map((icon) => `  "${icon}": ${toPascalCase(icon)}`).join(",\n");

  return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by vite-plugin-extract-icons
// Run 'bun run build' to regenerate

import type {LucideIcon} from "lucide-react";
import {${imports}} from "lucide-react";

export const iconMap: Record<string, LucideIcon> = {
${mapEntries},
};

export type IconName = keyof typeof iconMap;
`;
}

function regenerateIcons(rootDir: string, silent = false): void {
  const {icons, usages} = extractIconsFromMdx(rootDir);
  const outputPath = join(rootDir, OUTPUT_FILE);

  // Validate icons and show warnings
  const warnings = validateIcons(usages, rootDir);
  if (warnings.length > 0) {
    console.warn("\n[extract-icons] Invalid icon names found:");
    warnings.forEach((w) => console.warn(w));
    console.warn("");
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, {recursive: true});
  }

  // Generate and write the icons file
  const content = generateIconsFile(icons);

  // Only write and log if content changed
  const existing = existsSync(outputPath) ? readFileSync(outputPath, "utf-8") : "";
  if (existing !== content) {
    writeFileSync(outputPath, content);
    if (!silent) {
      const validCount = Array.from(icons).filter((i) => validLucideIcons.has(i)).length;
      console.log(`ðŸŽ¨ Generated icons.ts with ${validCount} icons`);
    }
  }
}

export function extractIconsPlugin(): Plugin {
  let rootDir: string;

  return {
    name: "vite-plugin-extract-icons",

    configResolved(config) {
      rootDir = config.root;
    },

    buildStart() {
      regenerateIcons(rootDir);
    },

    configureServer(server) {
      // Watch for MDX file changes
      server.watcher.add(join(rootDir, CONTENT_DIR, "**/*.mdx"));

      server.watcher.on("change", (file) => {
        if (file.endsWith(".mdx")) {
          regenerateIcons(rootDir, true);
        }
      });

      server.watcher.on("add", (file) => {
        if (file.endsWith(".mdx")) {
          regenerateIcons(rootDir, true);
        }
      });

      server.watcher.on("unlink", (file) => {
        if (file.endsWith(".mdx")) {
          regenerateIcons(rootDir, true);
        }
      });
    },
  };
}
